<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Pro Farm Sim Engine</title>
    <style>
        /* CSS RESET & MOBILE OPTIMIZATIONS */
        :root {
            --ui-bg: rgba(255, 255, 255, 0.95);
            --primary-color: #ff9f43;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none; /* Metin se√ßimini engelle */
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Scroll engelleme */
            background-color: #57c1eb; /* G√∂ky√ºz√º mavisi */
            font-family: var(--font-main);
            touch-action: none; /* Tarayƒ±cƒ± zoom/scroll hareketlerini engelle */
        }

        /* OYUN ALANI */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI KATMANI (DOM BASED UI) */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Tƒ±klamalar canvas'a ge√ßsin */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            pointer-events: auto; /* UI elemanlarƒ± tƒ±klanabilir olsun */
            padding: 10px;
            display: flex;
            gap: 10px;
        }

        #top-bar {
            background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%);
            color: white;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 1px 1px 2px black;
        }

        #bottom-bar {
            background: white;
            border-top: 4px solid var(--primary-color);
            padding: 15px;
            overflow-x: auto;
            justify-content: center;
        }

        /* TOOL BUTTONS */
        .tool-btn {
            width: 60px;
            height: 60px;
            background: #eee;
            border: 2px solid #ccc;
            border-radius: 12px;
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            position: relative;
        }

        .tool-btn.active {
            background: #ffeaa7;
            border-color: #fdcb6e;
            transform: translateY(-5px);
            box-shadow: 0 5px 0 #e1b12c;
        }

        .tool-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: red;
            color: white;
            font-size: 12px;
            border-radius: 50%;
            padding: 2px 6px;
        }

        /* TOAST MESSAGE */
        #toast-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .toast {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            animation: fadeUp 2s forwards;
        }

        @keyframes fadeUp {
            0% { opacity: 0; transform: translateY(20px); }
            10% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="top-bar" class="hud-panel">
            <div id="level-display">LVL 1</div>
            <div id="xp-display">XP: 0/100</div>
            <div style="flex-grow: 1;"></div>
            <div id="coin-display">üí∞ 500</div>
        </div>

        <div id="toast-container"></div>

        <div id="bottom-bar" class="hud-panel">
            </div>
    </div>
</div>

<script>
/**
 * PART 1: CONSTANTS & UTILS
 * Global sabitler ve yardƒ±mcƒ± fonksiyonlar.
 */

const CONFIG = {
    TILE_SIZE: 64, // Grid kare boyutu
    GRID_ROWS: 10,
    GRID_COLS: 8,
    FPS: 60,
    DEBUG: false,
    SAVE_KEY: 'ProFarmSim_V1',
    AUTOSAVE_INTERVAL: 10000 // 10 saniye
};

// √úr√ºn Veritabanƒ± (CropFactory i√ßin Data)
const CROP_DATA = {
    'wheat': { id: 'wheat', name: 'Buƒüday', emoji: 'üåæ', growthTime: 5000, buyPrice: 0, sellPrice: 2, xp: 1, unlockLevel: 1 },
    'corn': { id: 'corn', name: 'Mƒ±sƒ±r', emoji: 'üåΩ', growthTime: 10000, buyPrice: 1, sellPrice: 5, xp: 2, unlockLevel: 2 },
    'carrot': { id: 'carrot', name: 'Havu√ß', emoji: 'ü•ï', growthTime: 20000, buyPrice: 2, sellPrice: 8, xp: 4, unlockLevel: 3 },
    'pumpkin': { id: 'pumpkin', name: 'Balkabaƒüƒ±', emoji: 'üéÉ', growthTime: 60000, buyPrice: 5, sellPrice: 20, xp: 10, unlockLevel: 5 },
    'tree_apple': { id: 'tree_apple', name: 'Elma Aƒüacƒ±', emoji: 'üçé', growthTime: 120000, buyPrice: 50, sellPrice: 15, xp: 20, isTree: true, unlockLevel: 7 }
};

// Yardƒ±mcƒ± Ara√ßlar
class Utils {
    static clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    static randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    static formatCurrency(amount) {
        return amount.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }

    // AABB √áarpƒ±≈üma Testi (Basit Nokta vs Kutu)
    static pointInRect(x, y, rectX, rectY, rectW, rectH) {
        return x >= rectX && x <= rectX + rectW && y >= rectY && y <= rectY + rectH;
    }
}

// Global Event Bus (Observer Pattern)
class EventEmitter {
    constructor() {
        this.events = {};
    }
    on(event, listener) {
        if (!this.events[event]) this.events[event] = [];
        this.events[event].push(listener);
    }
    emit(event, data) {
        if (this.events[event]) {
            this.events[event].forEach(listener => listener(data));
        }
    }
}

// Global Event Emitter √ñrneƒüi
const EventBus = new EventEmitter();

</script><script>
/**
 * PART 2: ENGINE, ASSETS & INPUT
 * Oyun d√∂ng√ºs√º, asset √∂nbellekleme ve girdi y√∂netimi.
 */

// Asset Y√∂neticisi: Emojileri Bitmap'e √ßevirir (Performans i√ßin kritik)
class AssetManager {
    constructor() {
        this.cache = {};
        this.ctx = document.createElement('canvas').getContext('2d');
    }

    // Emojiyi √∂nceden render edip bellekte resim olarak tutar
    async preRenderEmoji(key, emoji, size = 64) {
        if (this.cache[key]) return;

        this.ctx.canvas.width = size;
        this.ctx.canvas.height = size;
        this.ctx.font = `${size * 0.8}px serif`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        // G√∂lge efekti ekle (Derinlik hissi)
        this.ctx.shadowColor = "rgba(0,0,0,0.3)";
        this.ctx.shadowBlur = 5;
        this.ctx.shadowOffsetX = 3;
        this.ctx.shadowOffsetY = 3;

        this.ctx.fillText(emoji, size / 2, size / 2 + (size * 0.1));
        
        // ImageBitmap olu≈ütur (Modern tarayƒ±cƒ±larda √ßok hƒ±zlƒ±dƒ±r)
        const bitmap = await createImageBitmap(this.ctx.canvas);
        this.cache[key] = bitmap;
    }

    get(key) {
        return this.cache[key];
    }
}

// Girdi Sistemi: Mouse ve Touch olaylarƒ±nƒ± birle≈ütirir
class InputSystem {
    constructor(canvas, camera) {
        this.canvas = canvas;
        this.camera = camera;
        this.activePointer = { x: 0, y: 0, isDown: false, id: null };
        this.rect = canvas.getBoundingClientRect();
        
        // Event Listener'lar
        this.setupEvents();
    }

    setupEvents() {
        const events = {
            start: ['mousedown', 'touchstart'],
            move: ['mousemove', 'touchmove'],
            end: ['mouseup', 'touchend', 'mouseleave']
        };

        // Touch ve Mouse olaylarƒ±nƒ± normalize et
        events.start.forEach(e => this.canvas.addEventListener(e, (evt) => this.onStart(evt), { passive: false }));
        events.move.forEach(e => document.addEventListener(e, (evt) => this.onMove(evt), { passive: false })); // Document dinlenir ki canvas dƒ±≈üƒ±na √ßƒ±karsa kopmasƒ±n
        events.end.forEach(e => document.addEventListener(e, (evt) => this.onEnd(evt)));
    }

    getPointerPos(evt) {
        let x, y;
        if (evt.touches && evt.touches.length > 0) {
            x = evt.touches[0].clientX;
            y = evt.touches[0].clientY;
        } else {
            x = evt.clientX;
            y = evt.clientY;
        }
        // Canvas koordinatlarƒ±na √ßevir
        const scaleX = this.canvas.width / this.rect.width;
        const scaleY = this.canvas.height / this.rect.height;
        
        return {
            x: (x - this.rect.left) * scaleX,
            y: (y - this.rect.top) * scaleY
        };
    }

    onStart(evt) {
        evt.preventDefault(); // Scroll engelle
        if (this.activePointer.isDown) return; // Multitouch'ƒ± ≈üimdilik basit tutuyoruz

        const pos = this.getPointerPos(evt);
        this.activePointer.x = pos.x;
        this.activePointer.y = pos.y;
        this.activePointer.isDown = true;
        
        // UI dƒ±≈üƒ±na tƒ±klanƒ±p tƒ±klanmadƒ±ƒüƒ± kontrol edilebilir
        EventBus.emit('INPUT_START', this.worldToGrid(pos.x, pos.y));
    }

    onMove(evt) {
        if (!this.activePointer.isDown) return;
        evt.preventDefault();

        const pos = this.getPointerPos(evt);
        this.activePointer.x = pos.x;
        this.activePointer.y = pos.y;

        // SWIPE TO ACT MANTIƒûI BURADA TETƒ∞KLENƒ∞R
        // S√ºrekli olarak parmaƒüƒ±n altƒ±ndaki gridi kontrol et
        EventBus.emit('INPUT_DRAG', this.worldToGrid(pos.x, pos.y));
    }

    onEnd(evt) {
        if (!this.activePointer.isDown) return;
        this.activePointer.isDown = false;
        EventBus.emit('INPUT_END', null);
    }

    // Ekran koordinatlarƒ±nƒ± Grid koordinatlarƒ±na (Row, Col) √ßevirir
    worldToGrid(screenX, screenY) {
        // Kamera ofseti buraya eklenebilir (Scrolling varsa)
        // ≈ûimdilik basit offset
        const offsetX = (this.canvas.width - (CONFIG.GRID_COLS * CONFIG.TILE_SIZE)) / 2;
        const offsetY = (this.canvas.height - (CONFIG.GRID_ROWS * CONFIG.TILE_SIZE)) / 2;

        const col = Math.floor((screenX - offsetX) / CONFIG.TILE_SIZE);
        const row = Math.floor((screenY - offsetY) / CONFIG.TILE_SIZE);

        return { col, row, valid: (col >= 0 && col < CONFIG.GRID_COLS && row >= 0 && row < CONFIG.GRID_ROWS) };
    }
}

// Ana Oyun Motoru: Loop ve DeltaTime y√∂netimi
class GameEngine {
    constructor() {
        this.lastTime = 0;
        this.accumulatedTime = 0;
        this.deltaTime = 1 / CONFIG.FPS;
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false }); // Alpha false performans artƒ±rƒ±r
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.assets = new AssetManager();
        this.isRunning = false;
        
        // Oyun bile≈üenleri (Sonraki partlarda dolacak)
        this.gridSystem = null; 
        this.particleSystem = null;
        this.uiManager = null;
    }

    resize() {
        // Retina ekranlar i√ßin DPI ayarƒ±
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = window.innerWidth * dpr;
        this.canvas.height = window.innerHeight * dpr;
        this.ctx.scale(dpr, dpr);
        
        // Input sistemi i√ßin rect'i g√ºncelle
        if(this.inputSystem) this.inputSystem.rect = this.canvas.getBoundingClientRect();
    }

    async init() {
        // Kritik assetleri y√ºkle
        await this.assets.preRenderEmoji('dirt', 'üü´');
        await this.assets.preRenderEmoji('plowed', 'üèæ');
        
        // Ekinleri y√ºkle
        for (let key in CROP_DATA) {
            await this.assets.preRenderEmoji(key, CROP_DATA[key].emoji);
            // Olgunla≈ümƒ±≈ü hali (Daha b√ºy√ºk veya parlak olabilir, ≈üimdilik aynƒ±sƒ±)
            await this.assets.preRenderEmoji(key + '_ripe', CROP_DATA[key].emoji, 72); 
            // Tohum hali
            await this.assets.preRenderEmoji('seed', 'üå∞', 32); 
        }
        
        this.start();
    }

    start() {
        this.isRunning = true;
        this.lastTime = performance.now();
        requestAnimationFrame((t) => this.loop(t));
    }

    loop(timestamp) {
        if (!this.isRunning) return;

        const frameTime = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        // Update (Sabit timestep opsiyonel, burada basit delta kullanƒ±yoruz)
        this.update(frameTime);

        // Render
        this.render();

        requestAnimationFrame((t) => this.loop(t));
    }

    update(dt) {
        if (this.gridSystem) this.gridSystem.update(dt);
        if (this.particleSystem) this.particleSystem.update(dt);
    }

    render() {
        // Arka planƒ± temizle
        this.ctx.fillStyle = '#57c1eb';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Sahneyi √ßiz
        if (this.gridSystem) this.gridSystem.render(this.ctx);
        if (this.particleSystem) this.particleSystem.render(this.ctx);
    }
}
</script><script>
/**
 * PART 3: GRID, CROPS & ECONOMY
 * Oyun mantƒ±ƒüƒ±, veri yapƒ±larƒ± ve ekin y√∂netimi.
 */

class EconomySystem {
    constructor() {
        this.coins = 500;
        this.xp = 0;
        this.level = 1;
        this.maxXp = 100;
    }

    addXp(amount) {
        this.xp += amount;
        if (this.xp >= this.maxXp) {
            this.levelUp();
        }
        EventBus.emit('UI_UPDATE', this);
    }

    levelUp() {
        this.level++;
        this.xp -= this.maxXp;
        this.maxXp = Math.floor(this.maxXp * 1.5);
        EventBus.emit('TOAST', `TEBRƒ∞KLER! SEVƒ∞YE ${this.level}`);
        // Ses efekti burada √ßalƒ±nabilir
    }

    spendCoins(amount) {
        if (this.coins >= amount) {
            this.coins -= amount;
            EventBus.emit('UI_UPDATE', this);
            return true;
        }
        return false;
    }

    addCoins(amount) {
        this.coins += amount;
        EventBus.emit('UI_UPDATE', this);
    }
}

class InventorySystem {
    constructor() {
        this.items = {}; // { 'wheat': 5, 'corn': 0 }
    }

    add(itemId, count) {
        if (!this.items[itemId]) this.items[itemId] = 0;
        this.items[itemId] += count;
        EventBus.emit('UI_UPDATE', null); // UI envanter sayƒ±sƒ±nƒ± g√ºncellesin
    }

    has(itemId, count = 1) {
        return (this.items[itemId] || 0) >= count;
    }

    remove(itemId, count) {
        if (this.has(itemId, count)) {
            this.items[itemId] -= count;
            EventBus.emit('UI_UPDATE', null);
            return true;
        }
        return false;
    }
}

// Tek bir kareyi temsil eden sƒ±nƒ±f
class Tile {
    constructor(row, col) {
        this.row = row;
        this.col = col;
        this.state = 'EMPTY'; // EMPTY, PLOWED, GROWING, RIPE, WITHERED
        this.cropType = null;
        this.plantTime = 0;
    }
}

class GridSystem {
    constructor(game) {
        this.game = game;
        this.rows = CONFIG.GRID_ROWS;
        this.cols = CONFIG.GRID_COLS;
        this.tiles = [];
        this.offsetX = 0;
        this.offsetY = 0;

        // Aktif ara√ß (UI'dan se√ßilen)
        this.currentTool = 'cursor'; // cursor, sickle, water, seed_wheat, etc.

        this.initGrid();
        this.setupListeners();
    }

    initGrid() {
        for (let r = 0; r < this.rows; r++) {
            this.tiles[r] = [];
            for (let c = 0; c < this.cols; c++) {
                this.tiles[r][c] = new Tile(r, c);
            }
        }
        this.centerGrid();
    }

    centerGrid() {
        // Gridi ekranƒ±n ortasƒ±na al
        const gridW = this.cols * CONFIG.TILE_SIZE;
        const gridH = this.rows * CONFIG.TILE_SIZE;
        this.offsetX = (this.game.canvas.width / window.devicePixelRatio - gridW) / 2;
        this.offsetY = (this.game.canvas.height / window.devicePixelRatio - gridH) / 2;
    }

    setupListeners() {
        // Kullanƒ±cƒ± bir araca tƒ±kladƒ±ƒüƒ±nda
        EventBus.on('TOOL_SELECTED', (toolId) => {
            this.currentTool = toolId;
            console.log("Tool Selected:", toolId);
        });

        // Swipe hareketi algƒ±landƒ±ƒüƒ±nda
        EventBus.on('INPUT_DRAG', (gridPos) => {
            if (gridPos.valid) {
                this.interact(gridPos.row, gridPos.col);
            }
        });
        
        // Tƒ±klama algƒ±landƒ±ƒüƒ±nda (Tek seferlik i≈ülem)
        EventBus.on('INPUT_START', (gridPos) => {
            if (gridPos.valid) {
                this.interact(gridPos.row, gridPos.col);
            }
        });
    }

    // OYUNUN KALBƒ∞: Etkile≈üim Mantƒ±ƒüƒ±
    interact(r, c) {
        const tile = this.tiles[r][c];
        const now = Date.now();

        // 1. HASAT ETME (Orak Aracƒ±)
        if (this.currentTool === 'sickle') {
            if (tile.state === 'RIPE') {
                this.harvest(tile);
            }
        }
        // 2. EKƒ∞M YAPMA (Tohum Se√ßiliyse)
        else if (this.currentTool.startsWith('seed_')) {
            const cropId = this.currentTool.split('_')[1]; // seed_wheat -> wheat
            
            // Eƒüer bo≈üsa √∂nce s√ºr√ºlmeli, eƒüer s√ºr√ºlm√º≈üse ekilebilir
            // Basitle≈ütirmek i√ßin: Bo≈üsa direkt eker ve s√ºrer (Hay Day tarzƒ±)
            if (tile.state === 'EMPTY' || tile.state === 'PLOWED') {
                this.plant(tile, cropId);
            }
        }
    }

    plant(tile, cropId) {
        const crop = CROP_DATA[cropId];
        // Para kontrol√º
        if (!this.game.economy.spendCoins(crop.buyPrice)) {
            EventBus.emit('TOAST', 'Yetersiz Para!');
            return;
        }

        tile.state = 'GROWING';
        tile.cropType = cropId;
        tile.plantTime = Date.now();
        
        // Partik√ºl efekti
        EventBus.emit('SPAWN_PARTICLE', { 
            x: this.offsetX + tile.col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2, 
            y: this.offsetY + tile.row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2,
            type: 'dust'
        });
    }

    harvest(tile) {
        const crop = CROP_DATA[tile.cropType];
        
        // √úr√ºn√º ver
        this.game.inventory.add(crop.id, 1);
        
        // XP ve Para (Para satƒ±lƒ±nca kazanƒ±lƒ±r ama XP hasatta gelir)
        this.game.economy.addXp(crop.xp);
        
        // Tile'ƒ± sƒ±fƒ±rla
        tile.state = 'EMPTY'; // Veya 'PLOWED' olarak kalabilir
        tile.cropType = null;

        // G√∂rsel Geri Bildirim (Juice)
        const centerX = this.offsetX + tile.col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;
        const centerY = this.offsetY + tile.row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;

        EventBus.emit('SPAWN_PARTICLE', { x: centerX, y: centerY, type: 'text', text: `+${crop.xp} XP` });
        EventBus.emit('SPAWN_PARTICLE', { x: centerX, y: centerY, type: 'item', emoji: crop.emoji });
    }

    update(dt) {
        // Ekin b√ºy√ºme kontrol√º
        const now = Date.now();
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                const tile = this.tiles[r][c];
                if (tile.state === 'GROWING') {
                    const crop = CROP_DATA[tile.cropType];
                    if (now - tile.plantTime >= crop.growthTime) {
                        tile.state = 'RIPE';
                    }
                }
            }
        }
    }

    render(ctx) {
        const ts = CONFIG.TILE_SIZE;

        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                const tile = this.tiles[r][c];
                const x = this.offsetX + c * ts;
                const y = this.offsetY + r * ts;

                // 1. Zemin √áizimi
                const groundImg = this.game.assets.get('dirt');
                if (groundImg) ctx.drawImage(groundImg, x, y, ts, ts);

                // Grid √ßizgileri (Opsiyonel, debug veya stil i√ßin)
                ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                ctx.strokeRect(x, y, ts, ts);

                // 2. Durum √áizimi
                if (tile.state === 'PLOWED') {
                    const plowed = this.game.assets.get('plowed');
                    if (plowed) ctx.drawImage(plowed, x, y, ts, ts);
                }
                else if (tile.state === 'GROWING') {
                    const crop = CROP_DATA[tile.cropType];
                    const seedImg = this.game.assets.get('seed');
                    
                    // B√ºy√ºme oranƒ±na g√∂re boyutlandƒ±rma (Lerp)
                    const now = Date.now();
                    const progress = Math.min(1, (now - tile.plantTime) / crop.growthTime);
                    
                    // Basit bir scale animasyonu
                    const size = ts * (0.3 + (progress * 0.4)); 
                    const offset = (ts - size) / 2;
                    
                    if (seedImg) ctx.drawImage(seedImg, x + offset, y + offset, size, size);
                    
                    // Progress bar (Sadece b√ºy√ºrken)
                    if (progress < 1) {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(x + 5, y + ts - 10, ts - 10, 4);
                        ctx.fillStyle = '#0f0';
                        ctx.fillRect(x + 5, y + ts - 10, (ts - 10) * progress, 4);
                    }
                }
                else if (tile.state === 'RIPE') {
                    const crop = CROP_DATA[tile.cropType];
                    const ripeImg = this.game.assets.get(tile.cropType + '_ripe'); // B√ºy√ºk g√∂rsel
                    // Sallanma animasyonu (Wind effect)
                    const sway = Math.sin(Date.now() / 200) * 2;
                    
                    if (ripeImg) ctx.drawImage(ripeImg, x + sway, y, ts, ts);
                }
            }
        }
        
        // Se√ßili kare vurgusu (Eƒüer mouse basƒ±lƒ±ysa)
        if (this.game.inputSystem.activePointer.isDown) {
            const pos = this.game.inputSystem.worldToGrid(this.game.inputSystem.activePointer.x, this.game.inputSystem.activePointer.y);
            if (pos.valid) {
                const x = this.offsetX + pos.col * ts;
                const y = this.offsetY + pos.row * ts;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 4;
                ctx.strokeRect(x, y, ts, ts);
            }
        }
    }
}
</script><script>
/**
 * PART 4: FX, UI, SAVE & MAIN
 * Partik√ºl efektleri, aray√ºz y√∂netimi ve ba≈ülatƒ±cƒ± kod.
 */

// Basit Partik√ºl Motoru (Visual Juice)
class ParticleSystem {
    constructor() {
        this.particles = [];
    }

    spawn(config) {
        // config: { x, y, type, text, emoji }
        this.particles.push({
            x: config.x,
            y: config.y,
            vx: (Math.random() - 0.5) * 2, // Saƒüa sola sa√ßƒ±lma
            vy: -2 - Math.random() * 2,    // Yukarƒ± fƒ±rlama
            life: 1.0,                     // 1 saniye √∂m√ºr
            type: config.type,
            text: config.text || '',
            emoji: config.emoji || ''
        });
    }

    update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.life -= dt;
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 5 * dt; // Yer√ßekimi

            if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
    }

    render(ctx) {
        ctx.font = "bold 20px Arial";
        ctx.textAlign = "center";

        this.particles.forEach(p => {
            ctx.globalAlpha = Utils.clamp(p.life, 0, 1);
            
            if (p.type === 'text') {
                ctx.fillStyle = "white";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.strokeText(p.text, p.x, p.y);
                ctx.fillText(p.text, p.x, p.y);
            } else if (p.type === 'item') {
                ctx.font = "30px Arial";
                ctx.fillText(p.emoji, p.x, p.y);
            } else if (p.type === 'dust') {
                ctx.fillStyle = "rgba(200, 200, 100, 0.5)";
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        ctx.globalAlpha = 1.0;
    }
}

class SaveManager {
    constructor(game) {
        this.game = game;
    }

    save() {
        const data = {
            tiles: this.game.gridSystem.tiles.map(row => row.map(t => ({
                s: t.state, c: t.cropType, p: t.plantTime
            }))),
            eco: { coins: this.game.economy.coins, xp: this.game.economy.xp, lvl: this.game.economy.level },
            inv: this.game.inventory.items,
            time: Date.now()
        };
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(data));
        EventBus.emit('TOAST', 'Oyun Kaydedildi');
    }

    load() {
        const raw = localStorage.getItem(CONFIG.SAVE_KEY);
        if (!raw) return false;

        try {
            const data = JSON.parse(raw);
            
            // Economy Y√ºkle
            this.game.economy.coins = data.eco.coins;
            this.game.economy.xp = data.eco.xp;
            this.game.economy.level = data.eco.lvl;

            // Inventory Y√ºkle
            this.game.inventory.items = data.inv || {};

            // Grid Y√ºkle (OFFLINE HESAPLAMA)
            const timeDiff = Date.now() - data.time;
            if (timeDiff > 10000) {
                 EventBus.emit('TOAST', `Sen yokken ${Math.floor(timeDiff/1000)}sn ge√ßti!`);
            }

            for (let r = 0; r < CONFIG.GRID_ROWS; r++) {
                for (let c = 0; c < CONFIG.GRID_COLS; c++) {
                    const tData = data.tiles[r][c];
                    const tile = this.game.gridSystem.tiles[r][c];
                    tile.state = tData.s;
                    tile.cropType = tData.c;
                    tile.plantTime = tData.p; // Zaman olduƒüu gibi y√ºklenir, oyun d√∂ng√ºs√º farkƒ± hesaplar
                }
            }
            return true;
        } catch (e) {
            console.error("Save dosyasƒ± bozuk", e);
            return false;
        }
    }
}

class UIManager {
    constructor(game) {
        this.game = game;
        this.elTopBar = {
            lvl: document.getElementById('level-display'),
            xp: document.getElementById('xp-display'),
            coin: document.getElementById('coin-display')
        };
        this.elBottomBar = document.getElementById('bottom-bar');
        this.toastContainer = document.getElementById('toast-container');

        this.buildToolbar();
        this.updateLabels();

        // Event Dinleyicileri
        EventBus.on('UI_UPDATE', () => this.updateLabels());
        EventBus.on('TOAST', (msg) => this.showToast(msg));
        EventBus.on('SPAWN_PARTICLE', (cfg) => this.game.particleSystem.spawn(cfg));
    }

    buildToolbar() {
        const tools = [
            { id: 'sickle', emoji: 'ü™ì', label: 'Hasat' }, // Hasat i√ßin Orak (Axe emojisi g√∂rsel olarak yakƒ±n)
            { id: 'seed_wheat', emoji: 'üåæ', label: 'Buƒüday', crop: 'wheat' },
            { id: 'seed_corn', emoji: 'üåΩ', label: 'Mƒ±sƒ±r', crop: 'corn' },
            { id: 'seed_carrot', emoji: 'ü•ï', label: 'Havu√ß', crop: 'carrot' },
            { id: 'seed_pumpkin', emoji: 'üéÉ', label: 'Kabak', crop: 'pumpkin' }
        ];

        tools.forEach(tool => {
            const btn = document.createElement('div');
            btn.className = 'tool-btn';
            btn.innerHTML = tool.emoji;
            btn.onclick = () => {
                // Active class y√∂netimi
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                EventBus.emit('TOOL_SELECTED', tool.id);
            };
            
            // Eƒüer √ºr√ºnse, stok miktarƒ±nƒ± badge olarak ekle (ƒ∞leri seviye √∂zellik)
            if (tool.crop) {
               // Badge ekleme kodu buraya gelebilir
            }

            this.elBottomBar.appendChild(btn);
        });

        // Varsayƒ±lan olarak ilk aracƒ± se√ß
        this.elBottomBar.firstChild.click();
    }

    updateLabels() {
        const eco = this.game.economy;
        this.elTopBar.lvl.innerText = `LVL ${eco.level}`;
        this.elTopBar.xp.innerText = `XP: ${eco.xp}/${eco.maxXp}`;
        this.elTopBar.coin.innerText = `üí∞ ${Utils.formatCurrency(eco.coins)}`;
    }

    showToast(msg) {
        const el = document.createElement('div');
        el.className = 'toast';
        el.innerText = msg;
        this.toastContainer.appendChild(el);
        setTimeout(() => el.remove(), 2100); // CSS animasyonundan biraz uzun
    }
}

// ----------------------------------------------------
// MAIN BOOTSTRAPPER (BA≈ûLATICI)
// ----------------------------------------------------
window.onload = async () => {
    try {
        const game = new GameEngine();
        
        // Alt Sistemlerin Baƒülanmasƒ±
        game.economy = new EconomySystem();
        game.inventory = new InventorySystem();
        game.inputSystem = new InputSystem(game.canvas);
        
        // Assetler y√ºklendikten sonra Grid olu≈ümalƒ±
        await game.init(); 

        game.gridSystem = new GridSystem(game);
        game.particleSystem = new ParticleSystem();
        game.uiManager = new UIManager(game);
        game.saveManager = new SaveManager(game);

        // Kayƒ±t Y√ºkle veya Yeni Ba≈ülat
        if (!game.saveManager.load()) {
            EventBus.emit('TOAST', 'Yeni √áiftliƒüine Ho≈ügeldin!');
        }

        // Autosave d√∂ng√ºs√º
        setInterval(() => game.saveManager.save(), CONFIG.AUTOSAVE_INTERVAL);

    } catch (err) {
        alert("Oyun ba≈ülatƒ±lƒ±rken kritik hata: " + err.message);
        console.error(err);
    }
};

</script>
</body>
</html>
